<!DOCTYPE html>
<html>
<head>
    <title>Nostr WebRTC Signaling (v2.15.0)</title>
    <script src="https://cdn.jsdelivr.net/npm/nostr-tools@2.15.0/nostr.bundle.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        input[type="text"] { width: 100%; padding: 8px; margin: 5px 0; box-sizing: border-box; }
        button { padding: 8px 15px; margin: 5px 0; cursor: pointer; }
        #messages { width: 100%; height: 200px; }
        #status { padding: 10px; margin: 10px 0; background: #f0f0f0; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>Nostr WebRTC 通訊 (v2.15.0)</h1>
    
    <div class="section">
        <h2>Nostr 設定</h2>
        <button id="generateKeys">生成新密鑰</button>
        <div>
            <label for="privateKey">私鑰 (nsec):</label>
            <input type="text" id="privateKey" placeholder="nsec1...">
        </div>
        <div>
            <label for="publicKey">公鑰 (npub1...):</label>
            <input type="text" id="publicKey" readonly>
        </div>
        <div>
            <label for="relayUrl">Relay URL:</label>
            <input type="text" id="relayUrl" value="wss://relay.damus.io">
        </div>
        <div>
            <label for="targetPubkey">目標公鑰 (npub1...):</label>
            <input type="text" id="targetPubkey" placeholder="npub1...">
        </div>
        <button id="connect">連接</button>
        <button id="disconnect" disabled>斷開連接</button>
    </div>
    
    <div class="section">
        <h2>通訊</h2>
        <textarea id="messages" rows="10" readonly></textarea><br>
        <input type="text" id="messageInput" placeholder="輸入訊息...">
        <button id="sendMessage" disabled>發送</button>
    </div>
    
    <div class="section">
        <h2>狀態</h2>
        <div id="status">未連接</div>
    </div>

    <script>
        // 全局變量
        let nostrPrivateKey = '';
        let nostrPublicKey = '';
        let relay = null;
        let subscription = null;
        let targetPubkey = '';
        
        // WebRTC 變量
        let peerConnection = null;
        let dataChannel = null;
        
        // DOM 元素
        const messagesTextarea = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessage');
        const statusDiv = document.getElementById('status');
        const generateKeysButton = document.getElementById('generateKeys');
        const connectButton = document.getElementById('connect');
        const disconnectButton = document.getElementById('disconnect');
        const privateKeyInput = document.getElementById('privateKey');
        const publicKeyInput = document.getElementById('publicKey');
        const relayUrlInput = document.getElementById('relayUrl');
        const targetPubkeyInput = document.getElementById('targetPubkey');
        
        // 初始化
        function init() {
            generateKeysButton.addEventListener('click', generateKeys);
            connectButton.addEventListener('click', startConnection);
            disconnectButton.addEventListener('click', disconnect);
            sendMessageButton.addEventListener('click', sendMessage);
            
            // 檢查localStorage是否有保存的密鑰
            if (localStorage.getItem('nostrPrivateKey')) {
                privateKeyInput.value = localStorage.getItem('nostrPrivateKey');
                updatePublicKey();
            }
        }
        
        // 生成新的Nostr密鑰對
        function generateKeys() {
            const privateKey = window.nostr.generatePrivateKey(); // 生成隨機私鑰
            const nsec = window.nostr.nip19.nsecEncode(privateKey); // 轉換為nsec格式
            privateKeyInput.value = nsec;
            localStorage.setItem('nostrPrivateKey', nsec);
            updatePublicKey();
        }
        
        // 更新公鑰顯示
        function updatePublicKey() {
            const nsec = privateKeyInput.value;
            try {
                if (nsec.startsWith('nsec1')) {
                    nostrPrivateKey = window.nostr.nip19.decode(nsec).data;
                    nostrPublicKey = window.nostr.getPublicKey(nostrPrivateKey);
                    const npub = window.nostr.nip19.npubEncode(nostrPublicKey);
                    publicKeyInput.value = npub;
                } else if (nsec.length === 64) {
                    // 兼容舊格式的hex私鑰
                    nostrPrivateKey = nsec;
                    nostrPublicKey = window.nostr.getPublicKey(nostrPrivateKey);
                    const npub = window.nostr.nip19.npubEncode(nostrPublicKey);
                    publicKeyInput.value = npub;
                }
            } catch (error) {
                console.error('密鑰解析錯誤:', error);
            }
        }
        
        // 開始連接
        async function startConnection() {
            // 解析私鑰
            const nsec = privateKeyInput.value;
            if (nsec.startsWith('nsec1')) {
                nostrPrivateKey = window.nostr.nip19.decode(nsec).data;
            } else if (nsec.length === 64) {
                nostrPrivateKey = nsec;
            } else {
                alert('無效的私鑰格式');
                return;
            }
            
            nostrPublicKey = window.nostr.getPublicKey(nostrPrivateKey);
            const npub = window.nostr.nip19.npubEncode(nostrPublicKey);
            publicKeyInput.value = npub;
            
            // 解析目標公鑰
            const targetNpub = targetPubkeyInput.value;
            if (!targetNpub.startsWith('npub1')) {
                alert('請輸入有效的npub1格式目標公鑰');
                return;
            }
            
            try {
                targetPubkey = window.nostr.nip19.decode(targetNpub).data;
            } catch (error) {
                alert('目標公鑰解析失敗: ' + error.message);
                return;
            }
            
            statusDiv.textContent = '正在連接Nostr relay...';
            connectButton.disabled = true;
            
            try {
                // 初始化Nostr relay連接
                const relayUrl = relayUrlInput.value;
                relay = await window.nostr.relayInit(relayUrl);
                await relay.connect();
                
                // 訂閱目標公鑰的消息 (使用kind 20000作為信號交換)
                subscription = relay.sub([
                    {
                        kinds: [20000],
                        authors: [targetPubkey],
                        '#p': [nostrPublicKey]
                    }
                ]);
                
                subscription.on('event', async (event) => {
                    try {
                        await handleNostrEvent(event);
                    } catch (error) {
                        console.error('處理Nostr事件錯誤:', error);
                        appendMessage('處理消息錯誤: ' + error.message);
                    }
                });
                
                // 初始化WebRTC
                await initWebRTC();
                
                statusDiv.textContent = '已連接Nostr relay，等待WebRTC連接...';
                disconnectButton.disabled = false;
            } catch (error) {
                console.error('連接錯誤:', error);
                statusDiv.textContent = '連接失敗: ' + error.message;
                connectButton.disabled = false;
            }
        }
        
        // 初始化WebRTC
        async function initWebRTC() {
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478?transport=udp' }
                ]
            };
            
            peerConnection = new RTCPeerConnection(configuration);
            
            // 處理ICE候選
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal({
                        type: 'candidate',
                        candidate: event.candidate
                    });
                }
            };
            
            // 處理連接狀態變化
            peerConnection.onconnectionstatechange = () => {
                statusDiv.textContent = `WebRTC狀態: ${peerConnection.connectionState}`;
                
                if (peerConnection.connectionState === 'connected') {
                    sendMessageButton.disabled = false;
                } else {
                    sendMessageButton.disabled = true;
                }
            };
            
            // 處理數據通道
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
            
            // 如果我們是發起方，創建數據通道
            if (nostrPublicKey.localeCompare(targetPubkey) < 0) {
                dataChannel = peerConnection.createDataChannel('chat');
                setupDataChannel();
                
                // 創建offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false
                });
                await peerConnection.setLocalDescription(offer);
                
                sendSignal({
                    type: 'offer',
                    sdp: offer.sdp
                });
            }
        }
        
        // 設置數據通道
        function setupDataChannel() {
            dataChannel.onopen = () => {
                appendMessage('數據通道已開啟');
                sendMessageButton.disabled = false;
            };
            
            dataChannel.onclose = () => {
                appendMessage('數據通道已關閉');
                sendMessageButton.disabled = true;
            };
            
            dataChannel.onmessage = (event) => {
                appendMessage(`對方: ${event.data}`);
            };
            
            dataChannel.onerror = (error) => {
                console.error('數據通道錯誤:', error);
                appendMessage(`錯誤: ${error.message}`);
            };
        }
        
        // 處理接收到的Nostr事件
        async function handleNostrEvent(event) {
            try {
                const content = JSON.parse(event.content);
                
                switch (content.type) {
                    case 'offer':
                        appendMessage('收到WebRTC offer');
                        if (!peerConnection) {
                            await initWebRTC();
                        }
                        
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: content.sdp
                        }));
                        
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        sendSignal({
                            type: 'answer',
                            sdp: answer.sdp
                        });
                        break;
                        
                    case 'answer':
                        appendMessage('收到WebRTC answer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: content.sdp
                        }));
                        break;
                        
                    case 'candidate':
                        await peerConnection.addIceCandidate(new RTCIceCandidate(content.candidate));
                        break;
                }
            } catch (error) {
                console.error('處理信號錯誤:', error);
                appendMessage(`信號處理錯誤: ${error.message}`);
            }
        }
        
        // 通過Nostr發送信號
        function sendSignal(signal) {
            if (!relay) return;
            
            const event = {
                kind: 20000, // 自定義kind用於信號交換
                created_at: Math.floor(Date.now() / 1000),
                tags: [['p', targetPubkey]],
                content: JSON.stringify(signal),
                pubkey: nostrPublicKey
            };
            
            event.id = window.nostr.getEventHash(event);
            event.sig = window.nostr.signEvent(event, nostrPrivateKey);
            
            relay.publish(event).catch(error => {
                console.error('發送信號失敗:', error);
                appendMessage(`發送信號失敗: ${error.message}`);
            });
        }
        
        // 發送消息
        function sendMessage() {
            const message = messageInput.value.trim();
            if (message && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(message);
                appendMessage(`我: ${message}`);
                messageInput.value = '';
            }
        }
        
        // 斷開連接
        function disconnect() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (subscription) {
                subscription.unsub();
                subscription = null;
            }
            
            if (relay) {
                relay.close();
                relay = null;
            }
            
            statusDiv.textContent = '已斷開連接';
            sendMessageButton.disabled = true;
            connectButton.disabled = false;
            disconnectButton.disabled = true;
        }
        
        // 添加消息到顯示區域
        function appendMessage(message) {
            messagesTextarea.value += `${new Date().toLocaleTimeString()}: ${message}\n`;
            messagesTextarea.scrollTop = messagesTextarea.scrollHeight;
        }
        
        // 啟動應用
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
